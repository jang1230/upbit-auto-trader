# 추가 요구사항 심층 분석

> **ultrathink 분석 결과**: 기본 설계 외 14개 핵심 영역 식별

---

## 📊 전체 요약

| 우선순위 | 항목 | Phase | 노력 | 중요도 |
|---------|-----|-------|-----|--------|
| ⭐⭐⭐⭐⭐ | 백테스팅 시스템 | 1.5 | 2-3일 | 필수 |
| ⭐⭐⭐⭐⭐ | API 키 암호화 | 1 | 0.5일 | 필수 |
| ⭐⭐⭐⭐⭐ | 에러 복구/재시작 | 5 | 1일 | 필수 |
| ⭐⭐⭐⭐ | 리스크 관리 강화 | 4 | 1일 | 높음 |
| ⭐⭐⭐⭐ | 텔레그램 알림 | 5-6 | 1-2일 | 높음 |
| ⭐⭐⭐⭐ | 성과 분석/통계 | 6-7 | 2일 | 높음 |
| ⭐⭐⭐ | 법적 고지/세금 | 6-7 | 1일 | 중간 |
| ⭐⭐⭐ | 사용자 가이드 | 6 | 1일 | 중간 |
| ⭐⭐⭐ | Headless 모드 | 1 | 0.5일 | 중간 |
| ⭐⭐⭐ | WebSocket | Phase 2 | 2일 | Phase 2 |
| ⭐⭐⭐ | 파라미터 최적화 | Phase 2 | 2일 | Phase 2 |
| ⭐⭐ | 다중 코인 거래 | Phase 2 | 3일 | Phase 2 |
| ⭐⭐ | 설정 마이그레이션 | 7 | 1일 | 낮음 |
| ⭐ | 웹 대시보드 | Phase 3+ | 5일 | 선택 |

---

## 1. 백테스팅 시스템 ⭐⭐⭐⭐⭐

### 필요성
**실제 돈을 투자하기 전에 전략을 검증해야 합니다.**

현재 설계는 5가지 전략을 제공하지만:
- 어떤 전략이 효과적인가?
- DCA 파라미터(배수 2.0, 간격 2%)가 최적인가?
- 최악의 시나리오는 어떤가?
- 예상 승률과 손익비는?

### 구현 내용

```python
class Backtester:
    def __init__(self, strategy, params, start_date, end_date):
        self.strategy = strategy
        self.params = params
        self.candles = self.load_historical_data(start_date, end_date)
        
    def run(self):
        """백테스트 실행"""
        portfolio = Portfolio(initial_capital=1_000_000)
        
        for candle in self.candles:
            # 지표 계산
            indicators = self.calculate_indicators(candle)
            
            # 전략 신호
            signal = self.strategy.check(indicators, candle)
            
            if signal == 'entry' and not portfolio.has_position():
                # 매수 시뮬레이션
                portfolio.enter(candle.close, self.params.base_amount)
                
            elif signal == 'dca' and portfolio.can_dca():
                # DCA 시뮬레이션
                portfolio.add_dca(candle.close)
                
            elif signal == 'exit' and portfolio.has_position():
                # 청산 시뮬레이션
                portfolio.exit(candle.close)
        
        return self.calculate_metrics(portfolio)
    
    def calculate_metrics(self, portfolio):
        """성과 지표 계산"""
        return {
            'total_return': portfolio.total_pnl_percent,
            'win_rate': portfolio.winning_trades / portfolio.total_trades,
            'sharpe_ratio': self.calculate_sharpe(portfolio.returns),
            'max_drawdown': self.calculate_mdd(portfolio.equity_curve),
            'avg_holding_time': portfolio.avg_holding_time,
            'profit_factor': portfolio.total_profit / portfolio.total_loss
        }
```

### GUI 통합

```
┌─ 백테스팅 ──────────────────────────────┐
│ 기간: [2023-01-01] ~ [2024-01-01]     │
│ 코인: [KRW-BTC ▼]                      │
│ 전략: [MACD + RSI ▼]                   │
│                                        │
│ [백테스트 실행]                         │
│                                        │
│ 📊 결과:                                │
│ ├─ 총 수익률: +45.2%                   │
│ ├─ 승률: 68% (25승 12패)                │
│ ├─ 평균 수익: +1.8%                     │
│ ├─ 최대 낙폭: -15.3%                    │
│ ├─ Sharpe Ratio: 1.3                  │
│ └─ Profit Factor: 2.1                  │
│                                        │
│ [상세 리포트] [전략 비교]               │
└────────────────────────────────────────┘
```

### 구현 위치
**Phase 1.5** (API 연동 직후, 실거래 전)

---

## 2. API 키 암호화 ⭐⭐⭐⭐⭐

### 필요성
API 키는 계좌 접근 권한이므로 평문 저장은 위험합니다.

### 구현 방법

```python
from cryptography.fernet import Fernet
import keyring

class SecureConfig:
    def __init__(self):
        # 시스템 키체인 사용
        # Windows: Credential Manager
        # macOS: Keychain
        # Linux: Secret Service API
        
        master_key = keyring.get_password("upbit_dca", "master_key")
        
        if not master_key:
            # 첫 실행: 마스터 키 생성
            master_key = Fernet.generate_key().decode()
            keyring.set_password("upbit_dca", "master_key", master_key)
        
        self.cipher = Fernet(master_key.encode())
    
    def encrypt_api_key(self, api_key):
        return self.cipher.encrypt(api_key.encode()).decode()
    
    def decrypt_api_key(self, encrypted_key):
        return self.cipher.decrypt(encrypted_key.encode()).decode()
```

### config.json 형식

```json
{
    "api_keys": {
        "access_key": "gAAAAABl... (encrypted)",
        "secret_key": "gAAAAABl... (encrypted)",
        "encryption_method": "Fernet-AES256"
    }
}
```

### 추가 패키지
```txt
cryptography>=41.0.0
keyring>=24.0.0
```

---

## 3. 에러 복구 및 재시작 로직 ⭐⭐⭐⭐⭐

### 필요성
24/7 무인 운영에서 예상치 못한 오류 발생 시 자동 복구가 필수입니다.

### 발생 가능한 오류

1. **네트워크 오류**: 일시적 인터넷 끊김, API 서버 다운
2. **API 오류**: Rate Limit, 인증 실패, 서버 오류
3. **시스템 오류**: 메모리 부족, Python 크래시, OS 재부팅
4. **데이터 오류**: SQLite 락, 로그 쓰기 실패

### 구현 내용

**1) 자동 재시도 (Exponential Backoff)**

```python
def api_call_with_retry(func, max_retries=3, backoff_factor=2):
    """지수 백오프로 재시도"""
    for attempt in range(max_retries):
        try:
            return func()
        except (ConnectionError, Timeout) as e:
            if attempt == max_retries - 1:
                raise
            wait_time = backoff_factor ** attempt
            logger.warning(f"API 오류, {wait_time}초 후 재시도: {e}")
            time.sleep(wait_time)
        except RateLimitError:
            logger.warning("Rate Limit 초과, 60초 대기")
            time.sleep(60)
```

**2) 상태 체크포인트**

```python
class AutoTrader:
    def save_checkpoint(self):
        """현재 상태를 디스크에 저장"""
        checkpoint = {
            'timestamp': datetime.now().isoformat(),
            'active_position': self.position.to_dict() if self.position else None,
            'pending_orders': self.pending_orders,
            'daily_pnl': self.daily_pnl
        }
        with open('data/checkpoint.json', 'w') as f:
            json.dump(checkpoint, f)
    
    def load_checkpoint(self):
        """프로그램 재시작 시 상태 복원"""
        if os.path.exists('data/checkpoint.json'):
            with open('data/checkpoint.json') as f:
                checkpoint = json.load(f)
            
            if checkpoint['active_position']:
                self.position = Position.from_dict(checkpoint['active_position'])
                logger.info(f"포지션 복원됨: {self.position}")
            
            # 미체결 주문 확인
            for order_uuid in checkpoint['pending_orders']:
                status = self.api.get_order_status(order_uuid)
                # 처리...
```

**3) Watchdog 스크립트**

```bash
#!/bin/bash
# start_bot.sh - 자동 재시작

while true; do
    python main.py
    EXIT_CODE=$?
    
    if [ $EXIT_CODE -eq 0 ]; then
        echo "정상 종료"
        break
    else
        echo "오류로 종료 (코드: $EXIT_CODE), 10초 후 재시작..."
        sleep 10
    fi
done
```

**4) 프로그램 시작 체크리스트**

```python
def startup_checks():
    """시작 시 필수 체크"""
    # 1. API 연결 테스트
    if not test_api_connection():
        raise RuntimeError("API 연결 실패")
    
    # 2. 이전 포지션 복원
    load_checkpoint()
    
    # 3. 미체결 주문 확인
    check_pending_orders()
    
    # 4. 디스크 공간 확인
    if get_free_space() < 100 * 1024 * 1024:  # 100MB
        logger.warning("디스크 공간 부족")
    
    # 5. 일일 손실 한도 리셋
    reset_daily_limits_if_needed()
```

---

## 4. 리스크 관리 강화 ⭐⭐⭐⭐

### 현재 설계의 리스크 관리
- 일일 손실 한도: -5%
- 손절 기준: -10%
- 최대 DCA 횟수: 5회

### 추가 필요 항목

**1) 변동성 필터**
```python
def check_volatility_filter(self, candles):
    """급격한 변동 시 거래 중지"""
    recent_5min = candles[-5:]
    price_change = (recent_5min[-1].close - recent_5min[0].close) / recent_5min[0].close * 100
    
    if abs(price_change) > 5.0:
        logger.warning(f"5분간 {price_change:.1f}% 변동, 거래 중지")
        return False
    
    return True
```

**2) 최대 투자 한도**
```python
class RiskManager:
    def __init__(self, total_capital):
        self.total_capital = total_capital
        self.max_position_ratio = 0.5  # 최대 50%까지만
    
    def can_invest(self, amount):
        """투자 가능 여부"""
        current_invested = self.get_total_invested()
        max_allowed = self.total_capital * self.max_position_ratio
        
        return (current_invested + amount) <= max_allowed
```

**3) 포지션 타임아웃**
```python
def check_position_timeout(self, position):
    """24시간 이상 보유 시 강제 청산"""
    if not position:
        return False
    
    holding_time = datetime.now() - position.entry_time
    if holding_time.total_seconds() > 24 * 3600:
        logger.warning("포지션 타임아웃, 강제 청산")
        return True
    
    return False
```

**4) 거래량 확인**
```python
def check_volume_safety(self, ticker):
    """거래량이 충분한지 확인"""
    avg_volume = ticker.acc_trade_volume_24h / 24
    current_volume = ticker.acc_trade_volume
    
    if current_volume < avg_volume * 0.3:
        logger.warning("거래량 부족, 주문 보류")
        return False
    
    return True
```

**5) 긴급 중지 조건**
```python
class EmergencyStop:
    def __init__(self):
        self.api_failure_count = 0
        self.last_successful_call = datetime.now()
    
    def should_stop(self):
        """긴급 중지 여부"""
        # API 연속 실패
        if self.api_failure_count >= 5:
            logger.critical("API 5회 연속 실패, 긴급 중지")
            return True
        
        # 오래된 마지막 성공
        if (datetime.now() - self.last_successful_call).total_seconds() > 300:
            logger.critical("5분간 API 응답 없음, 긴급 중지")
            return True
        
        # 시스템 리소스
        if psutil.virtual_memory().percent > 90:
            logger.critical("메모리 90% 초과, 긴급 중지")
            return True
        
        return False
```

---

## 5. 텔레그램 알림 시스템 ⭐⭐⭐⭐

### 필요성
24/7 무인 운영 시 원격 모니터링 및 제어가 필수입니다.

### 알림 종류

**Critical (긴급)**:
- 시스템 오류
- 일일 손실 한도 도달
- 긴급 중지

**High (중요)**:
- 주문 체결 (진입/청산)
- DCA 추가 매수
- 손절 실행

**Medium (보통)**:
- 전략 신호 감지
- API 경고

**Low (정보)**:
- 일일 요약
- 주간 통계

### 구현

```python
import telegram
from telegram.ext import Application, CommandHandler

class TelegramNotifier:
    def __init__(self, token, chat_id):
        self.bot = telegram.Bot(token=token)
        self.chat_id = chat_id
    
    async def send_trade_alert(self, trade_type, symbol, price, amount):
        """거래 알림"""
        emoji = "🟢" if trade_type == "BUY" else "🔴"
        message = f"""
{emoji} {trade_type} 체결

코인: {symbol}
가격: {price:,}원
수량: {amount:.8f}
시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
        """
        await self.bot.send_message(chat_id=self.chat_id, text=message)
    
    async def send_daily_summary(self, stats):
        """일일 요약"""
        message = f"""
📊 오늘의 거래 요약

총 거래: {stats['total_trades']}회
승률: {stats['win_rate']:.1f}%
수익: {stats['total_pnl']:+,}원 ({stats['pnl_percent']:+.2f}%)
최고 수익: {stats['best_trade']:+,}원
최악 손실: {stats['worst_trade']:,}원
        """
        await self.bot.send_message(chat_id=self.chat_id, text=message)

# 원격 제어
class TelegramController:
    def __init__(self, bot, trader):
        self.bot = bot
        self.trader = trader
        
        app = Application.builder().token(bot.token).build()
        app.add_handler(CommandHandler("status", self.cmd_status))
        app.add_handler(CommandHandler("stop", self.cmd_stop))
        app.add_handler(CommandHandler("start", self.cmd_start))
        app.add_handler(CommandHandler("stats", self.cmd_stats))
        app.run_polling()
    
    async def cmd_status(self, update, context):
        """현재 상태 조회"""
        position = self.trader.position
        
        if position:
            message = f"""
💼 현재 포지션

코인: {position.symbol}
평균단가: {position.avg_price:,}원
보유수량: {position.total_amount:.8f}
투자금액: {position.total_invested:,}원
현재가격: {position.current_price:,}원
수익률: {position.pnl_percent:+.2f}%
DCA 횟수: {position.dca_count}/5
            """
        else:
            message = "포지션 없음 (대기 중)"
        
        await update.message.reply_text(message)
    
    async def cmd_stop(self, update, context):
        """거래 중지"""
        self.trader.stop_trading()
        await update.message.reply_text("⏸ 거래가 중지되었습니다")
    
    async def cmd_start(self, update, context):
        """거래 재개"""
        self.trader.start_trading()
        await update.message.reply_text("▶️ 거래가 재개되었습니다")
```

### 설정

```json
{
    "telegram": {
        "enabled": true,
        "bot_token": "YOUR_BOT_TOKEN",
        "chat_id": "YOUR_CHAT_ID",
        "alerts": {
            "trade": true,
            "dca": true,
            "exit": true,
            "error": true,
            "daily_summary": true
        }
    }
}
```

### 추가 패키지
```txt
python-telegram-bot>=20.0
```

---

## 6. 성과 분석 및 통계 시스템 ⭐⭐⭐⭐

### 필요성
"얼마나 잘 작동하고 있는가"를 객관적으로 평가해야 합니다.

### 성과 지표

**1) 기본 수익 지표**
- 총 실현 손익 (원화)
- 총 수익률 (%)
- 일일/주간/월간 수익률
- 최고 수익 거래 / 최악 손실 거래

**2) 리스크 지표**
- **MDD (Maximum Drawdown)**: 최대 낙폭
- **Sharpe Ratio**: 위험 대비 수익률
- **Win Rate**: 승률 (수익 거래 / 전체 거래)
- **Profit Factor**: 총 수익 / 총 손실 비율

**3) 거래 통계**
- 총 거래 횟수
- 평균 보유 시간
- 평균 DCA 횟수
- 청산 사유별 비율 (목표달성/손절/타임아웃)

**4) 전략별 성과**
```
전략 1 (MACD+RSI):
- 거래 횟수: 25
- 승률: 68%
- 평균 수익: +1.8%
- Sharpe Ratio: 1.2

전략 2 (MA+RSI):
- 거래 횟수: 18
- 승률: 72%
- 평균 수익: +1.5%
- Sharpe Ratio: 1.5
```

### 데이터베이스 스키마

```sql
CREATE TABLE trades (
    id INTEGER PRIMARY KEY,
    symbol TEXT,
    strategy TEXT,
    entry_time TIMESTAMP,
    exit_time TIMESTAMP,
    entry_price REAL,
    exit_price REAL,
    quantity REAL,
    dca_count INTEGER,
    total_invested REAL,
    realized_pnl REAL,
    pnl_percent REAL,
    exit_reason TEXT  -- 'target', 'stop_loss', 'timeout', 'manual'
);

CREATE TABLE daily_summary (
    date DATE PRIMARY KEY,
    total_trades INTEGER,
    winning_trades INTEGER,
    total_pnl REAL,
    pnl_percent REAL,
    max_drawdown REAL,
    sharpe_ratio REAL
);
```

### 구현

```python
class PerformanceAnalyzer:
    def calculate_sharpe_ratio(self, returns, risk_free_rate=0.02):
        """샤프 비율 = (수익률 - 무위험수익률) / 변동성"""
        excess_returns = returns - risk_free_rate / 365
        return np.mean(excess_returns) / np.std(excess_returns) * np.sqrt(365)
    
    def calculate_max_drawdown(self, equity_curve):
        """최대 낙폭 = (최고점 - 최저점) / 최고점"""
        peak = np.maximum.accumulate(equity_curve)
        drawdown = (equity_curve - peak) / peak
        return np.min(drawdown) * 100
    
    def calculate_win_rate(self, trades):
        """승률 = 수익 거래 수 / 전체 거래 수"""
        winning_trades = len([t for t in trades if t.pnl > 0])
        return winning_trades / len(trades) * 100 if trades else 0
    
    def generate_report(self, start_date, end_date):
        """기간별 성과 리포트"""
        trades = self.db.get_trades(start_date, end_date)
        
        returns = [t.pnl_percent for t in trades]
        equity = self.calculate_equity_curve(trades)
        
        return {
            'total_pnl': sum(t.realized_pnl for t in trades),
            'total_trades': len(trades),
            'win_rate': self.calculate_win_rate(trades),
            'sharpe_ratio': self.calculate_sharpe_ratio(returns),
            'max_drawdown': self.calculate_max_drawdown(equity),
            'avg_holding_time': self.calculate_avg_holding_time(trades),
            'profit_factor': self.calculate_profit_factor(trades),
            'strategy_comparison': self.compare_strategies(trades)
        }
```

---

## 7. 법적 고지 및 세금 계산 ⭐⭐⭐

### 필요성
법적 보호와 사용자의 세금 신고 편의를 위해 필요합니다.

### 한국 암호화폐 세금 (2024년 기준)

- **양도소득세**: 2025년 시행 예정 (유예 가능성)
- **세율**: 연 250만원 공제 후 22% (지방세 포함 24.2%)
- **기록 의무**: 모든 거래 내역 5년 보관

### 구현 기능

**1) 법적 고지사항**

```python
class LegalNotice(QDialog):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("이용 약관 및 면책 조항")
        
        notice_text = """
=== 이용 약관 및 면책 조항 ===

1. 투자 손실 책임
   본 프로그램은 자동매매 "도구"일 뿐이며, 투자 손실에 대한 
   책임은 전적으로 사용자에게 있습니다.

2. 수익 보장 불가
   과거 백테스팅 결과는 미래 수익을 보장하지 않습니다.
   암호화폐 시장은 높은 변동성을 가지고 있습니다.

3. 세금 신고 의무
   암호화폐 거래 수익에 대한 세금 신고는 사용자의 의무입니다.
   본 프로그램은 세금 계산 보조 기능만 제공합니다.

4. 보안 책임
   API 키 관리 및 계좌 보안은 사용자의 책임입니다.

5. 교육 목적
   본 프로그램은 교육 및 연구 목적으로 제공됩니다.

위 사항에 동의하십니까?
        """
        
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.text_edit.setText(notice_text)
        
        self.agree_checkbox = QCheckBox("위 내용을 읽었으며 동의합니다")
        self.accept_button = QPushButton("동의하고 시작")
        self.accept_button.setEnabled(False)
        
        self.agree_checkbox.stateChanged.connect(
            lambda: self.accept_button.setEnabled(self.agree_checkbox.isChecked())
        )
```

**2) 세금 계산 모듈**

```python
class TaxCalculator:
    TAX_RATE = 0.242  # 22% + 지방세 2.2%
    TAX_EXEMPTION = 2_500_000  # 250만원 공제
    
    def calculate_annual_tax(self, trades, year):
        """연간 세금 계산"""
        year_trades = [t for t in trades if t.exit_time.year == year]
        
        # 실현 손익만 계산
        realized_pnl = sum(t.realized_pnl for t in year_trades if t.exit_time)
        
        if realized_pnl <= self.TAX_EXEMPTION:
            return {
                'taxable_income': realized_pnl,
                'tax_amount': 0,
                'exempt_amount': self.TAX_EXEMPTION - realized_pnl
            }
        
        taxable = realized_pnl - self.TAX_EXEMPTION
        tax = taxable * self.TAX_RATE
        
        return {
            'taxable_income': realized_pnl,
            'exempt_used': self.TAX_EXEMPTION,
            'taxable_amount': taxable,
            'tax_amount': tax
        }
    
    def export_for_tax_report(self, year, output_path):
        """세무사 제출용 리포트"""
        trades = self.db.get_trades_by_year(year)
        
        df = pd.DataFrame([{
            '거래일시': t.exit_time.strftime('%Y-%m-%d %H:%M:%S'),
            '종목': t.symbol,
            '취득가': t.entry_price,
            '양도가': t.exit_price,
            '수량': t.quantity,
            '실현손익': t.realized_pnl,
            '수수료': t.total_fee
        } for t in trades])
        
        df.to_excel(output_path, index=False)
```

**3) GUI 통합**

```
┌─ 세금 정보 ──────────────────────────┐
│ 2024년 세금 계산                     │
│                                      │
│ 총 실현 손익: 3,250,000원            │
│ 기본 공제: -2,500,000원              │
│ 과세 대상: 750,000원                 │
│ 예상 세금: 181,500원 (24.2%)         │
│                                      │
│ [상세 내역] [엑셀 내보내기]           │
└──────────────────────────────────────┘
```

---

## 8. 사용자 온보딩 및 학습 자료 ⭐⭐⭐

### 필요성
초보자도 쉽게 사용할 수 있도록 가이드가 필요합니다.

### 구현 내용

**1) 첫 실행 Setup Wizard**

```python
class SetupWizard(QDialog):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Upbit DCA 봇 설정 마법사")
        
        # 페이지 1: 환영 및 소개
        self.page1 = self.create_welcome_page()
        
        # 페이지 2: API 키 설정
        self.page2 = self.create_api_page()
        
        # 페이지 3: 경험 수준 선택
        self.page3 = self.create_experience_page()
        
        # 페이지 4: 프리셋 선택
        self.page4 = self.create_preset_page()
        
        # 페이지 5: 완료
        self.page5 = self.create_completion_page()
    
    def create_preset_page(self):
        """프리셋 선택"""
        presets = {
            '초보자 (보수적)': {
                'base_amount': 10_000,
                'dca_ratio': 2.0,
                'dca_interval': 3.0,  # 넓은 간격
                'max_dca_count': 3,    # 적은 횟수
                'profit_target': 1.5,
                'stop_loss': -8.0
            },
            '중급자 (균형)': {
                'base_amount': 10_000,
                'dca_ratio': 2.0,
                'dca_interval': 2.0,
                'max_dca_count': 5,
                'profit_target': 1.0,
                'stop_loss': -10.0
            },
            '공격적': {
                'base_amount': 10_000,
                'dca_ratio': 2.5,
                'dca_interval': 1.5,  # 좁은 간격
                'max_dca_count': 7,    # 많은 횟수
                'profit_target': 0.8,
                'stop_loss': -15.0
            }
        }
        
        # 각 프리셋 설명 및 선택 UI
```

**2) 인터랙티브 툴팁**

```python
class TooltipLabel(QLabel):
    def __init__(self, text, tooltip_text):
        super().__init__(text)
        
        info_icon = QLabel(" ℹ️ ")
        info_icon.setToolTip(tooltip_text)
        info_icon.setStyleSheet("""
            QLabel {
                color: #00d4aa;
                font-weight: bold;
                cursor: pointer;
            }
        """)

# 사용 예시
dca_ratio_label = TooltipLabel(
    "DCA 배수:",
    """
    DCA 배수는 매수 금액이 증가하는 비율입니다.
    
    예시 (배수 2.0):
    1차: 10,000원
    2차: 20,000원
    3차: 40,000원
    4차: 80,000원
    
    높을수록 공격적, 낮을수록 보수적입니다.
    """
)
```

**3) 시뮬레이션 계산기**

```
┌─ DCA 시뮬레이터 ────────────────────┐
│ 초기 가격: [50,000    ] 원          │
│ 하락률: [10         ] %             │
│ 기본 금액: [10,000    ] 원          │
│ DCA 배수: [2.0       ]              │
│ DCA 간격: [2.0       ] %            │
│                                     │
│ [계산하기]                           │
│                                     │
│ 📊 결과:                             │
│ 1차: 50,000원 → 10,000원 투자        │
│ 2차: 49,000원 → 20,000원 투자        │
│ 3차: 48,020원 → 40,000원 투자        │
│ 4차: 47,060원 → 80,000원 투자        │
│ 5차: 46,119원 → 160,000원 투자       │
│                                     │
│ 총 투자: 310,000원                   │
│ 평균 단가: 47,287원                  │
│ 청산 목표: 47,760원 (+1.0%)          │
└─────────────────────────────────────┘
```

**4) FAQ 섹션**

```
Q: 하루에 얼마나 벌 수 있나요?
A: 시장 상황과 전략에 따라 다릅니다. 백테스팅 결과를 참고하세요.
   평균적으로 월 3-5% 수익을 목표로 합니다.

Q: 원금 손실 가능성은?
A: 암호화폐는 고위험 자산입니다. 손실 가능성이 항상 있으며,
   투자 금액은 손실해도 괜찮은 범위 내에서 설정하세요.

Q: 24시간 컴퓨터를 켜둬야 하나요?
A: 네, 또는 VPS(클라우드 서버)를 사용할 수 있습니다.
   VPS 설정 가이드를 참고하세요.

Q: 여러 코인을 동시에 거래할 수 있나요?
A: Phase 2 기능으로 계획되어 있습니다.
```

---

## 9. Headless 모드 (CLI) ⭐⭐⭐

### 필요성
VPS에서는 GUI를 사용할 수 없으므로 CLI 모드가 필요합니다.

### 구현

```python
# main.py
import argparse

def main():
    parser = argparse.ArgumentParser(description='Upbit DCA Trading Bot')
    parser.add_argument('--headless', action='store_true',
                       help='Run without GUI (for VPS)')
    parser.add_argument('--config', default='data/config.json',
                       help='Config file path')
    parser.add_argument('--log-level', default='INFO',
                       choices=['DEBUG', 'INFO', 'WARNING', 'ERROR'],
                       help='Logging level')
    
    args = parser.parse_args()
    
    # 로깅 설정
    setup_logging(args.log_level)
    
    if args.headless:
        logger.info("Starting in headless mode...")
        
        # CLI 모드
        config = load_config(args.config)
        bot = AutoTrader(config)
        bot.start()
        
        # 무한 루프
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            logger.info("Shutting down...")
            bot.stop()
            logger.info("Bot stopped successfully")
    
    else:
        # GUI 모드
        app = QApplication(sys.argv)
        window = MainWindow()
        window.show()
        sys.exit(app.exec())

if __name__ == "__main__":
    main()
```

### 사용 예시

```bash
# GUI 모드 (기본)
python main.py

# Headless 모드
python main.py --headless

# 다른 설정 파일 사용
python main.py --headless --config /path/to/config.json

# 디버그 로깅
python main.py --headless --log-level DEBUG
```

---

## 10-14. Phase 2 이후 기능

### 10. WebSocket 실시간 시세 ⭐⭐⭐

- **목적**: Rate Limit 절약, 저지연
- **Phase**: Phase 2
- **노력**: 2일

### 11. 파라미터 최적화 ⭐⭐⭐

- **목적**: 전략 개선
- **Phase**: Phase 2
- **노력**: 2일
- **기능**: 그리드 서치, 베이지안 최적화

### 12. 다중 코인 동시 거래 ⭐⭐

- **목적**: 포트폴리오 분산
- **Phase**: Phase 2
- **노력**: 3일
- **기능**: PortfolioManager, 자금 배분, Rate Limit 분배

### 13. 설정 마이그레이션 ⭐⭐

- **목적**: 버전 업그레이드 대비
- **Phase**: Phase 7
- **노력**: 1일

### 14. 웹 대시보드 ⭐

- **목적**: 원격 모니터링 (텔레그램 대안)
- **Phase**: Phase 3+
- **노력**: 5일

---

## 📋 수정된 전체 개발 계획

| Phase | 기능 | 기간 | 누적 |
|-------|-----|-----|------|
| **Phase 1** | API 연동 + 보안 + Headless | 2일 | 2일 |
| **Phase 1.5** | 백테스팅 시스템 ✅ | 2-3일 | 4-5일 |
| **Phase 2** | 지표 + 전략 | 2일 | 6-7일 |
| **Phase 3** | 포지션 + 리스크 강화 ✅ | 2일 | 8-9일 |
| **Phase 4** | 자동 거래 + 에러 복구 ✅ | 2일 | 10-11일 |
| **Phase 5** | 텔레그램 알림 ✅ | 1-2일 | 11-13일 |
| **Phase 6** | GUI + 가이드 ✅ | 3일 | 14-16일 |
| **Phase 7** | 통합 + 통계 + 세금 ✅ | 3일 | 17-19일 |

**총 예상 기간**: **17-19일** (기존 9-13일 → 증가)

### 증가 이유
- ⭐⭐⭐⭐⭐ 필수 기능 5개 추가 (+7일)
- ⭐⭐⭐⭐ 중요 기능 2개 추가 (+3일)

**증가된 시간은 투자 가치가 있습니다**:
- 백테스팅으로 손실 방지
- 에러 복구로 무인 운영 안정성
- 텔레그램으로 편의성 대폭 향상
- 통계로 지속적 개선 가능

---

## ✅ 최종 권장사항

### 절대 건너뛰면 안 되는 것

1. **백테스팅 (Phase 1.5)** ⭐⭐⭐⭐⭐
   - 실거래 전 반드시 검증
   - 최소 6개월 데이터로 테스트

2. **API 키 암호화 (Phase 1)** ⭐⭐⭐⭐⭐
   - 보안은 선택이 아닌 필수

3. **에러 복구 (Phase 4)** ⭐⭐⭐⭐⭐
   - 24/7 무인 운영의 핵심

### 강력히 권장하는 것

4. **리스크 관리 강화 (Phase 3)** ⭐⭐⭐⭐
   - 변동성 필터, 포지션 타임아웃 등

5. **텔레그램 알림 (Phase 5)** ⭐⭐⭐⭐
   - VPS 운영 시 필수

6. **성과 분석 (Phase 7)** ⭐⭐⭐⭐
   - 전략 개선의 기반

### 있으면 좋은 것

7. **법적 고지 (Phase 7)** ⭐⭐⭐
   - 자신을 보호하세요

8. **사용자 가이드 (Phase 6)** ⭐⭐⭐
   - 진입 장벽 낮추기

---

**문서 버전**: 1.0
**작성일**: 2024-01-15
**분석 방법**: Ultrathink (Sequential Thinking)
